Вариант 5

DP Builder - порождающий паттерн проектирования, позволяющий создавать сложные объекты "по цепочке" или "пошагово". Этот паттерн инкапсулирует создание объекта. Это позволяет скрыть сложность и упростить его использование. В основном хорошим признаком для использования паттерна Builder является большое количество параметров в конструкторе объекта, причем большинство параметров не обязательные. Также он повышает читаемость кода, код становится более "human-readable".

Пример использования на практике: 

public class Logger
{
    public string LogLevel { get; private set; } = "INFO";
    public string Output { get; private set; } = "Console";
    public string Format { get; private set; } = "{Timestamp} [{Level}] {Message}";

    private Logger() { }

    public void Log(string message)
    {
        var timestamp = DateTime.Now.ToString("o");
        var formattedMessage = Format
            .Replace("{Timestamp}", timestamp)
            .Replace("{Level}", LogLevel)
            .Replace("{Message}", message);

        if (Output == "Console")
        {
            Console.WriteLine(formattedMessage);
        }
        else if (Output == "File")
        {
            File.AppendAllText("log.txt", formattedMessage + Environment.NewLine);
        }
    }

    public class Builder
    {
        private string _logLevel = "INFO";
        private string _output = "Console";
        private string _format = "{Timestamp} [{Level}] {Message}";

        public Builder SetLogLevel(string logLevel)
        {
            _logLevel = logLevel;
            return this;
        }

        public Builder SetOutputToConsole()
        {
            _output = "Console";
            return this;
        }

        public Builder SetOutputToFile()
        {
            _output = "File";
            return this;
        }

        public Builder SetFormat(string format)
        {
            _format = format;
            return this;
        }

        public Logger Build()
        {
            return new Logger
            {
                LogLevel = _logLevel,
                Output = _output,
                Format = _format
            };
        }
    }
}

Использование: 
var consoleLogger = new Logger.Builder()
                    .SetLogLevel("DEBUG")
                    .SetOutputToConsole()
                    .SetFormat("{Timestamp} - {Level}: {Message}")
                    .Build();

consoleLogger.Log("Application started.");

Закон иерархических компенсаций Седова : говорит о том, что если на одном уровне системы мы упрощаем работу, то на другом уровне она усложняется. Например, когда используем фреймворк, он берёт на себя много задач, которые нам не нужно делать вручную,например, маршрутизацию или обработку запросов. Но из-за этого мы должны больше разбираться в работе самого фреймворка, настраивать его и следить за его обновлениями.
То же самое с микросервисами. Каждая часть приложения становится проще, но их взаимодействие, то есть настройка API, мониторинг и деплой усложняется. Или с ORM, мы не пишем SQL, но должны понимать, как ORM генерирует запросы, чтобы не было проблем с производительностью.
Суть закона в том, что работа не исчезает, а просто "переезжает" на другой уровень. Упрощение в одном месте всегда означает дополнительные задачи в другом.

Декомпозиция ООП: существуют принципы декомпозиции ООП: наследование, инкапсуляция, полиморфизм и разделение ответственности.
Преимущества ООП-декомпозиции
1. Читаемость: Сложная задача разбивается на отдельные, легко понимаемые маленькие.
2. Модульность: Классы и объекты можно разрабатывать, тестировать и использовать независимо.
3. Удобство изменений: Если нужно изменить логику нижних слоев архитектуры, это не повлияет на логику верхних слоев архитектуры.

Статический полиморфизм: это полиморфизм, который определяется на этапе компиляции, а не в рантайме. Проявляется в перегрузке методов и операторов. То есть существует несколько методов с одинаковым именем, но с разной сигнатурой методов. Могут отличаться параметры, тип параметров, их количество.

Инкапсуляция: один из принципов ООП. Говорит о том, что нужно скрывать от пользователя внутреннюю работу сервиса/приложения/класса. Проще говоря: предоставлять пользователю только то, что ему требуется. Конечного пользователя (обычного юзера приложения или другого разработчика) не должно касаться то, как это работает твое приложение/класс внутри, им нужен только удобный полный контракт и интерфейс использования этого. Инкапсуляция проявляется как и в создании обычного класса, так и в полном проектировании приложений. Инкапсуляция на примере web-api: у других разработчиков и пользователей есть только endpoints для использования и общения с web-api, у них нет доступа к внутреннему устройству приложения, к сервисам, которые используют контроллеры и так далее.